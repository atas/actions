name: "Detect Changed Directories"
description: "Detects which immediate subdirectories under a given path have changed files. Uses the GitHub API — works with shallow checkouts."
branding:
  icon: folder
  color: blue

inputs:
  path:
    description: "Parent directory to trigger_all for changes (e.g., 'jobs' or 'services')"
    required: false
    default: "."
  trigger_all:
    description: "Extra paths to trigger_all — if any files change here, ALL subdirs under 'path' are returned (e.g., 'shared-py' or 'shared-py,lib')"
    required: false
    default: ""

outputs:
  dirs:
    description: "JSON array of changed directory names (e.g., ['api', 'worker'])"
    value: ${{ steps.detect.outputs.dirs }}
  any:
    description: "Whether any directories changed ('true' or 'false')"
    value: ${{ steps.detect.outputs.any }}

runs:
  using: composite
  steps:
    - id: detect
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        INPUT_PATH: ${{ inputs.path }}
        INPUT_TRIGGER_ALL: ${{ inputs.trigger_all }}
      run: |
        # Normalize: strip trailing slash
        path="${INPUT_PATH%/}"

        # Get changed files based on event type
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          files=$(gh api "repos/${{ github.repository }}/pulls/${{ github.event.number }}/files" --paginate --jq '.[].filename')
        elif [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
          files=$(gh api "repos/${{ github.repository }}/compare/${{ github.event.before }}...${{ github.sha }}" --jq '.files[].filename')
        else
          # workflow_dispatch or new branch — return all subdirectories
          dirs=$(ls -d "${path}"/*/ 2>/dev/null | xargs -n1 basename | jq -R . | jq -sc .)
          echo "Changed dirs: ${dirs}"
          echo "dirs=${dirs}" >> "$GITHUB_OUTPUT"
          if [ "$dirs" = "[]" ]; then
            echo "any=false" >> "$GITHUB_OUTPUT"
          else
            echo "any=true" >> "$GITHUB_OUTPUT"
          fi
          exit 0
        fi

        # If any trigger_alled paths have changes, return ALL subdirs
        if [ -n "$INPUT_TRIGGER_ALL" ]; then
          IFS=',' read -ra trigger_all_paths <<< "$INPUT_TRIGGER_ALL"
          for wp in "${trigger_all_paths[@]}"; do
            wp=$(echo "$wp" | xargs)  # trim whitespace
            if echo "$files" | grep -q "^${wp}/"; then
              dirs=$(ls -d "${path}"/*/ 2>/dev/null | xargs -n1 basename | jq -R . | jq -sc .)
              echo "Watch path '${wp}' changed — returning all dirs: ${dirs}"
              echo "dirs=${dirs}" >> "$GITHUB_OUTPUT"
              if [ "$dirs" = "[]" ]; then echo "any=false"; else echo "any=true"; fi >> "$GITHUB_OUTPUT"
              exit 0
            fi
          done
        fi

        # Filter to path, extract immediate subdirectory names, deduplicate
        # Then filter out directories that no longer exist (e.g., deleted/renamed)
        candidates=$(echo "$files" | grep "^${path}/" | cut -d/ -f$(( $(echo "$path" | tr -cd '/' | wc -c) + 2 )) | sort -u || true)
        dirs=$(echo "$candidates" | while read -r d; do if [ -n "$d" ] && [ -d "${path}/${d}" ]; then echo "$d"; fi; done | jq -R . | jq -sc .)

        echo "Changed dirs: ${dirs}"
        echo "dirs=${dirs}" >> "$GITHUB_OUTPUT"
        if [ "$dirs" = "[]" ]; then
          echo "any=false" >> "$GITHUB_OUTPUT"
        else
          echo "any=true" >> "$GITHUB_OUTPUT"
        fi
